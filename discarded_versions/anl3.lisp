(defpackage :anl
  (:use :cl)
  (:export)
  (:shadow :find))
(in-package :anl)

(setf *words*
      '((adj wet green soft quick formless empty watery)
	(adv quickly)
	(art a an the)
	(con (+ and or)
	     (s for nor but yet so))
	(desc very)
	(ing greening singing hovering moving)
	(loc now then)
	(n (sg green soup member beginning God earth shape darkness surface deep spirit water light)
	   (pl soups heavens))
	(p in on under above out of without over to)
	(part be)
	(pro it that him her them he they we us me I there)
	(v (present (simp sweep jump get creates want wants be is)
		    (comp (*comp* get out of)))
	   (inf (*comp* to sing))
	   (imp make let sing)
	   (past (simp created was wanted got said)
		 (comp (*comp* got out of) (*comp* looked up)))
	   (future (*comp* will sing))) ;I don't think there are any 1-word
	(punc (quot |"| |'|))))
(set-macro-character #\] (get-macro-character #\)))
(set-macro-character #\[ #'(lambda (stream char) `(lambda (_) ,(read-delimited-list #\] stream t))))
(defun class-1st (lst)
  (labels ((find (l n)
		 (if (symbolp n)
		     (if (eq (car l) n) 1 0)
		   (if (eq (car n) '*comp*)
		       (if (reduce (lambda (a b) (and a b))
				   (loop for x on l and y in (cdr n)
					 collecting (plusp (find x y))))
			   (length (cdr n))
			 0)
		     (remove-if [member (cadr _) '(0 nil)]
				(mapcar [list (car n) (find l _)] n)))))
	   (runfind (ls) (remove nil (mapcar [find ls _] *words*)))
	   (doone (i)
		  (if (listp i)
		      (if (= (length i) 1)
			  (doone (car i))
			(let ((r (doone (cadr i))))
			  (cons (cons (car i) (car r))
				(cdr r))))
		    (list nil (subseq lst 0 i) (subseq lst i))))
	   (arrange (out)
		    (if (and (= (length out) 2) (symbolp (car out)))
			(doone out)
		      (mapcar #'arrange out))))
	  (when lst
	    (mapcar [list (list (car _) (cadr _)) (caddr _)]
		    (apply #'append (arrange (runfind lst)))))))
(defun tag-sen (sen)
  (let ((l (class-1st sen)) (r nil))
    (when l
      (loop while l
	    do (let* ((s (pop l))
		      (p (class-1st (cadr s))))
		 (if (cadr s)
		     (when p
		       (dolist (ls p)
			 (let* ((i (if (symbolp (caaar s))
				       (list (car s) (car ls))
				     (append (car s) `(,(car ls))))))
			   (if (cadr ls)
			       (push (list i (cadr ls)) l)
			     (push i r)))))
		   (push (car s) r))))
      (or (ignore-errors (and (caaaar r) r)) (list r)))))
(defun match= (a b strict)
  (if strict
      (equal a b)
    (loop for x in (mapcar #'equal a b) always x)))
(defun match-pats (p1 p2 strict)
  (and (= (length p1) (length p2))
       (loop for x in (mapcar (lambda (a b) (match= a b strict)) p1 p2)
	     always x)))
(defun match-1 (lst pat &optional (strict nil))
  (when (and lst pat)
    (match-pats (subseq (mapcar #'car lst) 0 (length pat))
		(mapcar [if (symbolp _) (list _) _] pat)
		strict)))
(defmacro or-let* (vars body)
  (let ((this nil) (later nil))
    (setf this (loop for x on vars while (not (eq (caar x) 'or))
		     collect (car x) finally (setf later x)))
    `(let* ,this
       ,(if later
	    `(or ,@(mapcar [list 'or-let* (if (listp (car _))
					      (append _ (cdr later))
					    (cons _ (cdr later))) body]
			   (cdar later)))
	  body))))
(defmacro match-fn (name pat &body body)
  (labels ((dop (pp &optional (strict nil))
		(let ((g (gensym)))
		  `(,(car pp)
		    (block ,(if strict nil name)
			   (or (ignore-errors
				 (let ((,g (multiple-value-list (funcall ',(cadr pp) lst))))
				   (if (and (car ,g) (cadar ,g))
				       (progn
					 (setf lst (cadr ,g))
					 (car ,g))
				     (return-from ,name nil))))
			       (if (match-1 lst ',(or (and (ignore-errors (caar (cadr pp)))
							   (cadr pp))
						      (list (cadr pp)))
					    ,(caddr pp))
				   (cadr (pop lst))
				 (return-from ,name nil)))))))
	   (single (term &optional (all nil))
		   (case (car term)
			 (? (dop (cdr term) nil))
			 (* (let ((ll (dop (cdr term) nil)) (g (gensym)))
			      `(,(car ll)
				(loop for ,g = ,(cadr ll)
				      while (and ,g lst) collect ,g))))
			 (+ (let ((m (single (cons '* (cdr term)))))
			      `(,(car m) ,(if all
					      (cadr m)
					    `(or ,(cadr m) (return-from ,name nil))))))
			 (or `(or ,@(mapcar [if (listp (car _)) (mapcar [single _ t] _) (single _ t)] (cdr term))
				   (,(gensym) (return-from ,name nil))))
			 (t (dop term all)))))
	  (let ((g (gensym)))
	    `(defun ,name (,g)
	       ;(format t "(~a ~a)~%" ',name ,g)
	       (or-let* ((lst ,g)
		      ,@(loop for i in pat collecting (single i)))
		 (flet ((ret-form (f) (return-from ,name (values f lst))))
		       ,@body))))))
(defmacro quick-match (name type pat strict)
  (let ((arg '()) (is nil) (flags '(list)) (descs '(list)) (other '()))
    (loop for i in pat do
	  (if (eq (car i) '!)
	      (push `(list nil ,(cadr i) ',(caddr i)) flags)
	    (let ((g (gensym))
		  (l (if (member (car i) '(? * + or)) (cdr i) i))
		  (s (if (member (car i) '(? * + or)) (car i) nil)))
	      (push `(,g ,(car l) ,strict) arg)
	      (when s (push s (car arg)))
	      (ccase (cadr l)
		     (is (setf is g))
		     (flags (push (list 'list t (caddr l) g) flags))
		     (descs (push (list 'list t (caddr l) g) descs))
		     (other (when (caddr l) (push (caddr l) other))
			 (push g other))))))
    (when (equal flags '(list)) (setf flags nil))
    (when (equal descs '(list)) (setf descs nil))
    `(match-fn ,name ,(reverse arg)
	       (ret-form (list ',type ,is
			       (apply #'append
				      (mapcar [if (cadr _) (cdr _) (cddr _)]
					      (remove-if [and (car _) (not (caddr _))]
							 ,(reverse flags))))
			       (apply #'append
				      (mapcar [if (cadr _) (cdr _) (cddr _)]
					      (remove-if [and (car _) (not (caddr _))]
							 ,(reverse descs))))
			       ,@(reverse other))))))
(defvar *pats* '())
(defmacro -defor (name fns)
  (let ((g (gensym)) (i (gensym)) (l (gensym)))
    (push name *pats*)
    `(defun ,name (,g)
       (dolist (,i ',fns)
	 (let ((,l (multiple-value-list (funcall ,i ,g))))
	   (when (and (car ,l) (cadar ,l))
	     (return-from ,name (values (car ,l) (cadr ,l)))))))))
(defmacro defor (name fns)
  (let ((g (gensym)))
    (push name *pats*)
    `(defun ,name (in)
       (remove nil (loop for f in ',fns collecting (funcall f in))))))
(defmacro very-quick-match (pats)
  (let ((ls '()))
    (loop for i in pats do
	  (let ((i2 i))
	    (when (< (length i2) 4) (push (gensym) i2))
	    (push (car i2) *pats*)
	    (push 'quick-match i2)
	    (push i2 ls)))
    `(progn ,@ls)))
(defclass parsenode ()
  ((type
    :initarg :type
    :reader type
    :initform nil)
   (is
    :initarg :is
    :accessor is
    :initform nil)
   (flags
    :initarg :flags
    :accessor flags
    :initform nil)
   (descs
    :initarg :descs
    :accessor descs
    :initform nil)
   (other
    :initarg :other
    :accessor other
    :initform nil)))
(defun copy-node (node)
  (make-instance 'parsenode :type (type node) :is (is node) :flags (flags node) :descs (descs node) :other (other node)))
(defun node= (n1 n2)
  (and
   (equal (type n1) (type n2))
   (equal (is n1) (is n2))
   (equal (flags n1) (flags n2))
   (equal (descs n1) (descs n2))
   (equal (other n1) (other n2))))
(defun trash (&other stuff) nil)
(defsetf trash trash)
(defmacro --match-fn (name type args) ;(mode type location [flag] [strict]) {skip [strict, they're all strict now]}
  (let ((l (gensym)) (r (gensym)) (lst (gensym)) (where '(is cadr flags caddr descs cadddr other fifth ! trash)))
    `(defun ,name (,lst)
       (let ((,l ,lst) (,r (make-instance 'parsenode :type ',type)))
	 ,@(mapcar [symbol-macrolet ((~$let `(multiple-value-list (,(cadr _) ,l)))
				     (~where `(,(getf where (caddr _)) ,r))
				     (~flag `(when ,(cadddr _) (push ,(cadddr _) ,~where)))
				     (~1push `(push (cadr (pop ,l)) ,~where))
				     ;(~1= `(if (symbolp ',(cadr _)) (eq (caaar ,l) ',(cadr _)) (match= (caar ,l) ',(cadr _))))
				     (~1= `(equal (caar ,l) (if (symbolp ',(cadr _)) '(,(cadr _)) ',(cadr _))))
				     (~fnok `(and (car ,a) (cadar ,a)))
				     (~fail `(return-from ,name nil))
				     (~$push `(push (car ,a) ,~where))
				     ;(~lset `(setf ,l (cadr ,a)))
				     (~lset `(loop until (equal ,l (cadr ,a)) do (pop ,l)))
				     )
				    (let ((a (gensym)))
				      (ccase (car _)
					     (1 `(if ,~1= (progn ,~1push ,~flag) ,~fail))
					     ($ `(let ((,a ,~$let))
						   (if ,~fnok
						       (progn ,~$push ,~flag ,~lset)
						     ,~fail)))
					     (1? `(when ,~1= ,~1push ,~flag))
					     ($? `(let ((,a ,~$let))
						    (when ,~fnok ,~$push ,~flag ,~lset)))
					     (1* `(loop for ,a = ,~1= while ,a do ,~1push))
					     ($* `(loop for ,a = ,~$let while ,~fnok do (progn ,~$push ,~lset)))
					     (! `(progn (push ',(cadr _) ,~where) (push ',(cadddr _) ,~where)))))]
		   args)
	 (setf (cadr ,r) (caadr ,r))
	 (values ,r ,l)))))
(defmacro --match-fn-2 (name type args)
  `(defun ,name (input-list)
     (let ((rl (list (list (make-instance 'parsenode :type ',type) (copy-tree input-list)))))
       ,@(mapcar [ccase (car _)
			(1 `(setf rl (remove nil
					     (mapcar [if (equal (caaadr _) ',(if (symbolp (cadr _)) (list (cadr _)) (cadr _)))
							 (let ((a (pop (cadr _))))
							   (push (cadr a) (,(caddr _) (car _)))
							   ,(when (cadddr _) `(push ',(cadddr _) (,(caddr _) (car _))))
							   _)
						       nil]
						     rl))))
			($ `(setf rl (loop for x in rl appending
					   (loop for y in (,(cadr _) (cadr x)) collecting
						 (let ((r (copy-node (car x))))
						   (push (car y) (,(caddr _) r))
						   (list r (copy-tree (cadr y))))))))
			(1? `(setf rl (mapcar [if (equal (caaadr _) ',(if (symbolp (cadr _)) (list (cadr _)) (cadr _)))
						  (let ((a (pop (cadr _))))
						    (push (cadr a) (,(caddr _) (car _)))
						    ,(when (cadddr _) `(push ',(cadddr _) (,(caddr _) (car _))))
						    _)
						_]
					      rl)))
			(--$? `(setf rl (loop for x in rl appending
					    (cons x
						  (loop for y in (,(cadr _) (cadr x)) collecting
							(let ((r (list (copy-node (car x)) (cadr y))))
							  (push (car y) (,(caddr _) (car r)))
							  r))))))
			($? `(setf rl (loop for x in rl appending
					    (cons x
						  (loop for y in (,(cadr _) (cadr x)) collecting
							(let ((r (copy-node (car x))))
							  (push (car y) (,(caddr _) r))
							  (list r (copy-tree (cadr y)))))))))
			(1* `(setf rl (mapcar [let ((x (copy-node (car _))) (lr (copy-list (cadr _))))
						(loop for l on (cadr _) while (equal (caar l) ',(if (symbolp (cadr _)) (list (cadr _)) (cadr _)))
						      do (progn
							   (push (cadar l) (,(caddr _) x))
							   (pop lr)))
						(list x lr)]
					      rl)))
			($* `(setf rl (let ((l rl) (c t))
					(loop while c do
					      (progn
						(setf c nil)
						(setf l (loop for x in l appending
							      (cons x
								    (loop for y in (,(cadr _) (cadr x)) collecting
									  (let ((r (list (copy-node (car x)) (cadr y))))
									    (push (car y) (,(caddr _) (car r)))
									    (setf c t)
									    r)))))))
					l)))
			(! `(loop for x in rl do (progn (push ',(cadr _) (flags (car x))) ,(when (cadddr _) `(push ',(cadddr _) (flags (car x)))))))
			]
		 args)
       rl)))
(defmacro multi-match (lst)
  `(progn
     ,@(mapcar [progn
		 (push (car _) *pats*)
		 (cons '--match-fn-2 _)]
	       lst)))
(multi-match (($prep prep ((1 p is) ($ $noun other)))
	      ($adv adv ((1? desc descs) (1 adv is)))
	      ($adj adj ((1? desc descs) (1 adj is)))
	      ($part verb ((1? desc descs) (1 part is) (! pastpart flags :tense)))
	      ($ding verb ((1? desc descs) (1 ing is) (! ing flags :tense)))
	      ($pro pro ((1 pro is)))
	      ($ing adj (($? $adv descs) (1 ing is) ($? $noun other :object) ($? $prep descs) (! ing flags :tense)))
	      ($inf verb ((1 (v inf) is) (! inf flags :tense) ($? $infobj other :object)))
	      ($vpasts verb (($? $vdir descs) ($ $object other :subject) ($? $adv descs) (1 (v past simp) is) ($? $object other :object) (! past flags :tense)))
	      ($vpastc verb (($? $vdir descs) ($ $object other :subject) ($? $adv descs) (1 (v past comp) is) ($? $object other :object) (! past flags :tense)))
	      ($vpasts1 verb (($? $vdir descs) ($ $object other :subject) ($? $adv descs) (1 (v past simp) is) ($? $obj other :object) (! past flags :tense)))
	      ($vpastc1 verb (($? $vdir descs) ($ $object other :subject) ($? $adv descs) (1 (v past comp) is) ($? $obj other :object) (! past flags :tense)))
	      ($vpresents verb (($? $vdir descs) ($ $object other :subject) ($? $adv descs) (1 (v present simp) is) ($? $object other :object) (! present flags :tense)))
	      ($vpresentc verb (($? $vdir descs) ($ $object other :subject) ($? $adv descs) (1 (v present comp) is) ($? $object other :object) (! present flags :tense)))
	      ($vpresents1 verb (($? $vdir descs) ($ $object other :subject) ($? $adv descs) (1 (v present simp) is) ($? $obj other :object) (! present flags :tense)))
	      ($vpresentc1 verb (($? $vdir descs) ($ $object other :subject) ($? $adv descs) (1 (v present comp) is) ($? $obj other :object) (! present flags :tense)))
	      ($vfuture verb (($? $vdir descs) ($ $object other :subject) ($? $adv descs) (1 (v future) is) ($? $object other :object) (! future flags :tense)))
	      ($vfuture1 verb (($? $vdir descs) ($ $object other :subject) ($? $adv descs) (1 (v future) is) ($? $obj other :object) (! future flags :tense)))
	      ($loc loc ((1 loc is)))
	      ($ns noun ((1? art flags :article) ($?;*
						  $ndesc descs) (1 (n sg) is) ($? $prep descs) (! nil flags :plural)))
	      ($np noun ((1? art flags :article) ($?;*
						  $ndesc descs) (1 (n pl) is) ($? $prep descs) (! t flags :plural)))
	      ($nss noun ((1? art flags :article) (1 (n sg) is) (! nil flags :plural)))
	      ($conobj con (($;*
			     $obj other) (1 (con +) is) ($ $obj other)))
	      ($convp+ con (($ $vp other) (1 (con +) is) ($ $vp other)))
	      ($convp con (($ $vp+ other) (1 (con s) is) ($ $vp+ other)))
	      ($vimp verb ((1 (v imp) is) ($? $vp other) (! imperitive flags :mode)))
	      ($quot quot ((1 (punc quot) is) ($ $sen other) (1 (punc quot) is)))
	      ($term term ((1 (punc quot) is) ($ $noun other) (1 (punc quot) is)))))
(defor $infobj ($noun $prep $adj $pro $quot))
(defor $obj ($infobj $inf $ing))
(defor $object ($conobj $obj))
(defor $vdir ($prep $loc))
(defor $ndesc ($adj $part $ding))
(defor $vp ($vpasts $vpastc $vpasts1 $vpastc1 $vpresents $vpresentc $vpresents1 $vpresentc1 $vfuture $vfuture1 $vimp))
(defor $vp+ ($convp+ $vp))
(defor $sen ($vp+ $convp))
(defor $noun ($ns $np))
(defor $thing ($vp+ $noun $ndesc))
;(delete-duplicates *pats*)
(defun parse-sentence (sen)
  (let ((ls '()))
    (loop for x in (tag-sen sen)
	  do (loop for f in *pats*
		   do (let ((p (multiple-value-list (funcall f x))))
			;(unless (cadr p)
			  (push (car p) ls))));)
    (remove-duplicates (remove nil ls) :test #'equal)))
(defun parse-sentence-2 (sen &optional all)
  (remove-duplicates (remove nil (loop for x in (tag-sen sen) appending
				       (loop for f in *pats* and p = (multiple-value-list (funcall f x))
					     if all collect (and (not (cadr p)) (car p))
					     else collect (car p))))
		     :test #'equal))
(defun parse-sentence (sen &optional all)
  (let ((ls nil))
    (dolist (x (tag-sen sen))
      (dolist (f *pats*)
	(let ((p ;(multiple-value-list
	       (funcall f x)));)
	  (when (car p)
	    (if all
		(when (not (cadr p))
		  ;(format t "~a~%" f)
		  (push p ls))
	      (push p ls))))))
    (mapcar #'car (remove-if-not #'cadar (remove-duplicates ls :test #'equal)))))
(defun output (sen)
  (format t "===~%~{  ~a~%~}" (parse-sentence sen t)))
(defun filter-list (ll)
  (if (listp ll)
      (let ((l (remove nil ll)))
	(if (= (length l) 1)
	    (filter (car l))
	  l))
    ll))
(defun output-2 (sen)
  (format t "===~%~{  ~a~%~}" (remove-duplicates (filter-list (remove nil (loop for s in (tag-sen sen)
						appending (loop for f in *pats* appending (funcall f (copy-tree s))))))
						 :test (lambda (a b) (and (ignore-errors (node= (car a) (car b))) (equal (cadr a) (cadr b)))))))
(defun get-slots (object) ;taken from http://stackoverflow.com/questions/3086561/make-clos-objects-printable-in-lisp
  ;; thanks to cl-prevalence
  (mapcar #'clos:slot-definition-name (clos:class-slots (class-of object))))
(defmethod print-object ((object parsenode) stream)
  (format stream "{~s ~s}" (type-of object)
      (loop for i in (get-slots object)
    collect (cons i (slot-value object i)))))
(output-2 '(In the beginning God created the heavens and the earth))
(output-2 '(Now the earth was without shape and empty and darkness was over the surface of the watery deep but the Spirit of God was moving over the surface of the water))
(output-2 '(God said |"| Let there be light |"| And there was light))
(output-2 '(God said light and soup and soup was light))
(output-2 '(there was light))
(format t "~a~%" ($noun (car (tag-sen '(the soup)))))
(format t "~a~%" ($prep (car (tag-sen '(in the soup)))))
(output-2 '(the beginning))
(format t "~a~%" ($nss (car (tag-sen '(the soup)))))
(output-2 '(the soup))
